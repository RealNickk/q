[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"Getting Started Determining if q is Something you Want to UseInstalling and Using qBaby Steps in Learning How to Use q","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"From the Repository​","type":1,"pageTitle":"Installation","url":"docs/Installation#from-the-repository","content":"You can clone the repository and get the Lua files needed to use q. This is not auto-updating, but there are no drawbacks other than that. You need gitinstalled to clone repositories. Provided that you have it installed, we can continue. tip If you don't feel like cloning the repository, you can go to src/q.luain the online Github repository and copy the code there. You can clone the repository with this command: git clone https://github.com/RealNickk/q.git  Once it finishes cloning, you can open it and inside src, there are the source files that you can use for your own purpose. "},{"title":"Roblox Environments​","type":1,"pageTitle":"Installation","url":"docs/Installation#roblox-environments","content":"You can create a ModuleScript in ReplicatedStorage and paste the contents ofq.lua into it. You can then require it: local q = require(path.to.q)  "},{"title":"Vanilla Environments​","type":1,"pageTitle":"Installation","url":"docs/Installation#vanilla-environments","content":"You can put q.lua in your Lua includes directory to require it, or you can put it in a directory relative to your script and load it with a relative path. local q = require(&quot;q&quot;) -- as include or in same directory local q = require(&quot;some/relative/path/to/q&quot;) -- as relative path  "},{"title":"Exploit Environments​","type":1,"pageTitle":"Installation","url":"docs/Installation#exploit-environments","content":"Open the root directory of your exploit and find the workspace directory. Paste q.lua into the workspace directory. You can load q by doing: local q = loadstring(readfile(&quot;q.lua&quot;))()  caution Your exploit may support filesystem functions but not have areadfile function, instead it might have their own name for it. You will have to look at your exploit's documentation to see if they support filesystem functions. The functions used here are using the Unified Naming Convention, which most mainstream exploits follow. Not all exploits support filesystem functions. If yours does not, you will have to load q using a different method. "},{"title":"Using Loadstring​","type":1,"pageTitle":"Installation","url":"docs/Installation#using-loadstring","content":"This is referring to Roblox exploit clients or Roblox servers, but if you have any class that can do web requests (vanilla Lua), it'll work fine. I'm only going to explain two ways to do it, both being through Roblox. This method is auto-updating but will have an extremely small delay since you have to make a web request. "},{"title":"Exploit Environments​","type":1,"pageTitle":"Installation","url":"docs/Installation#exploit-environments-1","content":"Scripts in exploit environments are different from how Roblox scripts work. You cannot just insert a ModuleScript into the game and set the source to the contents of q.lua, as Roblox compiles the script into bytecode and stores it in an offset in the C++ structure of the script. Since most exploits do not have the ability to write bytecode to a Lua source container, you will have to loadstring the contents of q.lua every time you want to use q, which has the drawback of environment sharing, since there is no sandboxing, but it's not a big deal unless you're doing some funky stuff. local q = loadstring(game:HttpGet(&quot;https://github.com/RealNickk/raw/main/q/src/q.lua&quot;))()  "},{"title":"Roblox Server Environments​","type":1,"pageTitle":"Installation","url":"docs/Installation#roblox-server-environments","content":"info This method only works if the ModuleScript is required by the server.ServerScriptService.LoadstringEnabled must be set to true to use q with this method. You can create a ModuleScript in ServerStorage and set the source to this: local HttpService = game:GetService(&quot;HttpService&quot;) local q = loadstring(HttpService:GetAsync(&quot;https://github.com/RealNickk/raw/main/q/src/q.lua&quot;))() return q  You can then require it from the server by doing: local q = require(path.to.q)  danger Using this method can open up your server to serverside arbitrary code execution vulnerabilities if you do not write good code. This means that people may be able to execute backdoors on your game's server end, giving exploiters full access to your game. I would recommend to not enable it unless you are testing in a volatile environment. It's always better to be safe than sorry. Next Step? You can view the API Reference page to learn how to use q. "},{"title":"Is q Something I Want to Use","type":0,"sectionRef":"#","url":"docs/IsQSomethingIWantToUse","content":"","keywords":""},{"title":"The problem​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#the-problem","content":"Say we have this code to add cash to a player's leaderboard status: function addCash(playerName, amount) PlayerList[playerName].leaderboard.Cash.Value += amount end addCash(&quot;builderman&quot;, 10)  I wrote this off the top of my head, and reading it makes me sick. This code is repulsive. There's no error handling, and it's not flexible. If you wanted to add more leaderboard stats, you would have to add more functions like this. This is not good practice and in the long run is not worth it. I didn't include that you have to keep refreshing the players list, but you get the point. That is, however, an entirely different topic that has nothing to do with typechecking which you can read about on your own time. We're going to use this code as an example regardless of how bad it is. Back to the main problem: What if I fed a string to addCash as the second argument without thinking about it? Even though the code might work, I could not verify whether or not it was sanitized, so if I had a stray character in there, my code would error. The error could be small, but what if it was big? What if it ran in a loop for all players (I have no clue who would do that, but bear with me)? There's lots of undefined behavior that can be hit if you make a mistake in your code, and you could miss it the first time. "},{"title":"The Solution​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#the-solution","content":"There is no wrong answer here per se, but I'll go over a couple of solutions that I've seen and why they're not ideal, then I'll go over the solution that I've come up with. tip Whichever method you like best, you can use. There is no right or wrong answer here. These are all adequate solutions, and maybe q isn't fit for you if you don't like how it solves this issue. It all boils down to how YOU like the problem to be solved. I'm just going over the different methods that I've seen and why I don't like them. "},{"title":"Luau Typechecking​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#luau-typechecking","content":"You might say that Luau has typechecking, and that's true. I have nothing against Luau typechecking, but it's not enough. Luau typechecking is only for static types, and it's not enough to catch all errors. For example, if I were to have a function that takes a function as an argument, I could pass a string to it and it would not error. Luau typechecking would not catch this error, because it's not a static type. It's a dynamic type. You can't check for dynamic types with Luau's typechecking. The second reason I'm not a fan of Luau typechecking is that it makes the code look slightly more complicated. I like my code to be as simple as possible, and I don't like having to write local x: number = 5 every time I want to make a variable. I like to be able to just write local x = 5 then check later on if it's a number and be done with it. Your preference may vary, but that's just my opinion. Regardless on whether or not I like Luau typechecking, here is an example of how you can solve the problem using it: function addCash(playerName: string, amount: number) PlayerList[playerName].leaderboard.Cash.Value += amount end addCash(&quot;builderman&quot;, 10) addCash(&quot;builderman&quot;, &quot;10&quot;) -- not allowed  Luau typechecking, even though it has its flaws, is still a good solution to the problem. It's fast, it's easy to use, and it's built into Roblox. It's a good solution, but it's not the solution I like. You may be using vanilla Lua, and you may not have Luau typechecking. If you're using vanilla Lua, you can use q to solve the problem. I'll go over that later on in the document, after I go over the next solution, which is using inline typechecking to solve the problem. "},{"title":"Inline Typechecking​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#inline-typechecking","content":"So, another solution I could do is to use type to check if the argument is a string or a number, but that's not very readable. function addCash(playerName, amount) assert(type(playerName) == &quot;string&quot;, &quot;bad argument #1 (expected string)&quot;) assert(type(amount) == &quot;number&quot;, &quot;bad argument #2 (expected number)&quot;) PlayerList[playerName].leaderboard.Cash.Value += amount end addCash(&quot;builderman&quot;, 10) addCash(&quot;builderman&quot;, &quot;10&quot;) --&gt; Script:3: bad argument #2 (expected number)  The issue with this code is that you need to write a lot of boilerplate code that can be easily done with a library. You also have to hardcode the argument number, which is not the best practice because if you were to insert an argument in the middle, you would have to change the argument number of every argument after it. This is tedious and not fun to do. Also, depending on how much arguments you have, you could be calling &quot;assert&quot; and &quot;type&quot; a lot, which is not very efficient. Here's the second drawback: With q, you can create your own custom types and typenames, and you can use them to check if the argument is the right fit for the function. This makes the code more readable, and most of all more flexible. Using inline typechecking, you can't do that. You can't create your own types and typenames, so if I only wanted to take, let's say an integer, not a decimal number, I would have to write a lot of boilerplate code to check if the number is an integer, where with q, I can just create a custom type called &quot;integer&quot; and use that to check if the argument is an integer. "},{"title":"Tuples​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#tuples","content":"A tuple is an ordered list of elements. This is a great example of arguments that are passed to a function. You can use the q.tuple function to create a tuple that you can then feed arguments for it to check. function addCash(playerName, amount) q.assert(q.tuple(q.string, q.number)) PlayerList[playerName].leaderboard.Cash.Value += amount end addCash(&quot;builderman&quot;, 10) addCash(&quot;builderman&quot;, &quot;10&quot;) --&gt; Script:7: invalid argument #2 (expected number, got string)  This is quite cleaner, don't you think? You also get more information about the problem in return such as the line number. Best part is you don't have to hardcode anything. Although this is easy, I think it could get easier to write. There are still drawbacks to this method. You have to writeq.assert(q.tuple(q.string, q.number)) every time you want to check arguments. This too, is tedious. Also, since this is a runtime check, it's not as efficient as Luau typechecking. It's not a big deal, but it's still something to consider. If you are planning to write code that runs ten million times a second, you might want to consider using Luau typechecking instead. "},{"title":"Wrappers​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#wrappers","content":"You could write a wrapper function that does the typechecking for you. This is similar to the last example, but it's a lot cleaner (in my opinion), and that's what I chose to do. local addCash = q.wrap(function(playerName, amount) PlayerList[playerName].leaderboard.Cash.Value += amount end, q.string, q.number) addCash(&quot;builderman&quot;, 10) addCash(&quot;builderman&quot;, &quot;10&quot;) --&gt; Script:6: invalid argument #2 (expected number, got string)  In my eyes, this is the best solution for general code. It's easy to write and easy to read. The code is still a piece of garbage, but that's not the point. The point is that you can verify the types of your arguments without running into the drawbacks that I went over in the last few examples. This still has an efficiency drawback, but it has the best readability and flexibility out of all the solutions I've gone over. "},{"title":"Conclusion​","type":1,"pageTitle":"Is q Something I Want to Use","url":"docs/IsQSomethingIWantToUse#conclusion","content":"As you saw, q is a great library to use for runtime typechecking. It's easy to use and easy to read, and it's efficient enough to use in most cases. I went over the fact that Luau typechecking may be enough for you, and that's fine. I just wanted to show you that there are other options out there that you can use if you don't like Luau typechecking or if you want to tackle a problem that Luau typechecking can't solve. If you think using q is the way to go for you, then you can continue reading the rest of the documentation to learn more about q and how to get started. If you don't think q is for you, then that's fine too. You can use Luau typechecking or you can use inline typechecking. It's all up to you. "},{"title":"The Basics of q","type":0,"sectionRef":"#","url":"docs/basics","content":"","keywords":""},{"title":"Syntax​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#syntax","content":"q is a typechecking library, but it's built to run without having to rewrite the compiler. It's built to run on top of vanilla Lua, which means that it's compatible with a couple of versions of Lua, namely 5.1, 5.2, 5.3, and LuaJIT. q is built to be as simple as possible, so it's syntax is very simple. It's syntax isn't similar to Luau's syntax, but it's easy to learn and easy to use. Here's an example of q's syntax: local q = require(game:GetService(&quot;ReplicatedStorage&quot;).q) print(q.string(&quot;Hello, world!&quot;)) --&gt; true  The first line is the same as any other require statement. The second line is where the magic happens. The property you choose is the type you want to check against. If the value is the type you specified, it will return true. If it's not, it will return false with argument 2 as the error message, and a possible third argument as the context which can be read about in the API reference. "},{"title":"Everyday Use​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#everyday-use","content":"q is built to be used in everyday Lua code. Whether it's a Roblox game or a seperate base, q is built to be used in any situation. Here's an example of q being used in a Roblox game: if q.string(&quot;Hello, world!&quot;) then print(&quot;This is a string!&quot;) else warn(&quot;This is not a string!&quot;) end  In this example, we're checking if the value is a string. If it is, we print &quot;This is a string!&quot;. If it's not, we follow the else statement and warn the player that it's not a string. This is useful for checking if a value is the type you want it to be. It's also useful for checking if a value is a certain type before doing something with it. q supports all of the vanilla Lua types, as well as some custom types. Some of the custom types will be explained next. "},{"title":"Nullables​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#nullables","content":"q supports nullables. This means that you can check if a value is a certain type, or nil. Here's an example: local nullOrString = q.nullable(q.string) print(nullOrString(&quot;Hello, world!&quot;)) --&gt; true print(nullOrString(nil)) --&gt; true print(nullOrString(1)) --&gt; false  In this example, we're checking if the value is a string or nil. If it is, it will return true. If it's not, it will return false. I would recommend using this over variants, as it's easier to use and easier to read. "},{"title":"Variants​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#variants","content":"Variants are a type that can be multiple types. They are useful for functions that can take multiple types at once. Here's an example of a variant: local variant = q.variant(q.string, q.number) print(variant(&quot;Hello, world!&quot;)) --&gt; true print(variant(2007)) --&gt; true print(variant(true)) --&gt; false  In this example, we're creating a new variant type. We're telling q that the variant can be a string or a number. We then check if the value is a string, which it is, so it returns true. After that, we checkif the value is a number, which it is, so it returns true. Lastly, we check if the value is a boolean, which it isn't, so it returns false. "},{"title":"Tuples​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#tuples","content":"Tuples are a list of values. They are useful for functions that take multiple arguments. Here's an example of a tuple: local tuple = q.tuple(q.string, q.number) print(tuple(&quot;Hello, world!&quot;, 2007)) --&gt; true print(tuple(&quot;Hello, world!&quot;, true)) --&gt; false  In this example, we're creating a new tuple type. We're telling q that the tuple is a list: [string, number]. We then check if the values are a string and a number, which they are, so it returns true. Afterwards, we check if the values are a string and a boolean, which they aren't, so it returns false. "},{"title":"Interfaces​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#interfaces","content":"Interfaces are a way to check if a table has certain properties. They can be used to check if a table has a certain method, or if it has a certain property. Here's an example of an interface: local person = q.interface({ Name = q.string, Age = q.number }) print(person({ Name = &quot;Nicholas&quot;, Age = 15 })) --&gt; true print(person({ Name = &quot;Nicholas&quot;, Age = 15, Extra = true })) --&gt; true print(person({ Name = &quot;Nicholas&quot;, Age = false })) --&gt; false  In this example, we're creating a new interface type. We're telling q that the interface is a table with the properties Name and Age. We then check if the first table matches the interface, which it does, so it returns true. After that, we check if the second table matches the interface, which it does, so it returns true. Lastly, we check if the third table matches the interface, which it doesn't, so it returns false. "},{"title":"Strict Interfaces​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#strict-interfaces","content":"Strict interfaces are pretty much 100% the same as interfaces, but they're strict. They're strict in the sense that they don't allow extra properties. Here's an example of a strict interface: local person = q.strictInterface({ Name = q.string, Age = q.number }) print(person({ Name = &quot;Nicholas&quot;, Age = 15 })) --&gt; true print(person({ Name = &quot;Nicholas&quot;, Age = 15, Extra = true })) --&gt; false print(person({ Name = &quot;Nicholas&quot;, Age = false })) --&gt; false  In this example, you can see that the table with the extra property returns false. This is because strict interfaces don't allow extra properties. The first table returns true because it doesn't have any extra properties. "},{"title":"User-Defined Types​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#user-defined-types","content":"The nice thing about having q is that it's flexible. You can use it in any situation, and you can create your own types to make up for other types that q doesn't have. Here's an example of using a custom type, where variants are not the best option: q.numberString = q.custom(&quot;numberString&quot;, function(self, obj) return q.string(obj) and (tonumber(obj) ~= nil) or q.number(obj) end) local doSomething = q.wrap(function(value) value = tonumber(value) print(type(value)) end, q.numberString) doSomething(1234) --&gt; number doSomething(&quot;5678&quot;) --&gt; number doSomething(&quot;Hello, world!&quot;) --&gt; invalid argument #1 (expected numberString, got string)  In this example, we're creating a new type called &quot;numberString&quot;. A numberString is a type that can be either a number or a string that can be converted to a number. We then create a function that takes a numberString as an argument. We then call the function with a number, a string that can be converted to a number, and a string that can't be converted to a number. The first two calls work, but the third one doesn't. This is because the third call is a string that can't be converted to a number, and q.numberString only allows strings that can be converted to numbers. "},{"title":"Processors​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#processors","content":"Do you see a problem in the last snippet? There is an issue with that code. The issue is that you have to still input boilerplate code to convert the string to a number. This is where processors come in. A processor is a function that runs after the function is called. It's useful for converting values to the type you want them to be. The problem with processors is that it makes it a lot harder to understand the code, and you're probably better off not using processors unless you really need them. Here's an example of using a processor: q.numberString = q.custom(&quot;numberString&quot;, function(self, obj) return q.string(obj) and (tonumber(obj) ~= nil) or q.number(obj) end) q.processNumberString = function(obj) return tonumber(obj) end local function _doSomething(value) print(type(value)) end local doSomething = q.pwrap( -- note that it's pwrap (wrap and process), not wrap _doSomething, { q.processNumberString }, { q.numberString } ) doSomething(1234) --&gt; number doSomething(&quot;5678&quot;) --&gt; number doSomething(&quot;Hello, world!&quot;) --&gt; invalid argument #1 (expected numberString, got string)  Processors call regardless of whether or not the value is the type you want it to be. It acts as the type but also converts the value to what you want. However, this is really ugly. You have to create a new function, and you have to create a new table for both the processors and arguments. I was unable to find a way to make this better, so if you have any suggestions, please let me know and I'll see what I can do. "},{"title":"Conclusion​","type":1,"pageTitle":"The Basics of q","url":"docs/basics#conclusion","content":"I went over the basics of q, including types, variants, tuples, interfaces, strict interfaces, user-defined types, and processors. I hope you learned something new. If you have any questions, feel free to ask me through the contact methods listed on my GitHub. If you're interested in contributing to q, feel free to make a pull request on GitHub. If you like my work, feel free to star the repository on GitHub. If you are interested in any other projects I've made, feel free to check out my GitHub profile. Thanks for reading! "},{"title":"q","type":0,"sectionRef":"#","url":"api/q","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"q","url":"api/q#types","content":" "},{"title":"Handler​","type":1,"pageTitle":"q","url":"api/q#Handler","content":"&lt;/&gt; type Handler = (...: any) → ( success: boolean, err: string?, context: table? ) A handler function for a QType. This function takes in any number of parameters with any type. The first return argument is a boolean indicating whether the typecheck passed or not. The second return argument is the error message if the typecheck failed. The third return argument is returned for extra context on the object. note The context argument is only passed when needed. In documentation, it will explicitly state if and when it is passed, and there will be an interface defined for it. Here is a code snippet of a handler function: local function isInstance(obj) local typeName = typeof(obj) if typeName ~= &quot;Instance&quot; then return false, string.format(&quot;expected an Instance, got %s&quot;, typeName), { ObjectType = typeName } end return true end   "},{"title":"ProcessorHandler​","type":1,"pageTitle":"q","url":"api/q#ProcessorHandler","content":"&lt;/&gt; type ProcessorHandler = (obj: T) → any A function that processes a value. This is used in q.pwrap. q.numberString = q.custom(&quot;numberString&quot;, function(self, obj) return q.string(obj) and (tonumber(obj) ~= nil) or q.number(obj) end) q.processNumberString = function(obj) return tonumber(obj) end local function _doSomething(value) print(type(value)) end local doSomething = q.pwrap( _doSomething, { q.processNumberString }, { q.numberString } ) doSomething(1234) --&gt; number doSomething(&quot;5678&quot;) --&gt; number doSomething(&quot;Hello, world!&quot;) --&gt; invalid argument #1 (expected numberString, got string) This is really ugly, so if anyone has a better way to do this, please let me know.  "},{"title":"QType​","type":1,"pageTitle":"q","url":"api/q#QType","content":"&lt;/&gt; type QType = userdata | table A custom type defined by the user. These can be called like a function with parameters to typecheck them. Refer to Handler for more information on how to call these user-defined types. You can get the typename of a QType by using q.typeName. warning QTypes are not meant to be used with type or typeof. You must use q.typeName to get the name of a QType. q.typeName will fallback to the typeof function for ease of use. QTypes can be accessed and written to like a table for use in the handler function. caution In some versions of Lua, QTypes are userdatas. In newer versions of Lua, QTypes are tables. This is due to the fact that newproxy was removed in newer versions of Lua. This library will automatically detect if your version of Lua can create userdatas from code. However, this means that you should NEVER use q.userdata or q.table to check if an object is a QType. Instead, use q.qtype to check if an object is a QType. You can still access and write to the QType like a table, but you must use q.isQType to check if an object is a QType. QTypes are created using q.custom. Here is an example of adding support for an Instance type: local q = require(path.to.q) q.instance = q.custom(&quot;Instance&quot;, function(obj) local typeName = typeof(obj) if typeName ~= &quot;Instance&quot; then return false, string.format(&quot;expected an Instance, got %s&quot;, typeName), { ObjectType = typeName } end return true end) q.instance(game) -- true q.instance(&quot;hello&quot;) -- false   "},{"title":"TupleContext​","type":1,"pageTitle":"q","url":"api/q#TupleContext","content":"&lt;/&gt; interface TupleContext { TypeName: string Index: number } A context object that is passed to the handler function of a tuple. It contains the typename of the object being checked and the index of the object in the tuple.  "},{"title":"Tuple​","type":1,"pageTitle":"q","url":"api/q#Tuple","content":"&lt;/&gt; type Tuple = QType A type that represents arguments or parameters to a function. Tuples can also be used to typeheck numbered tables (lists). Tuples are created using q.tuple. Here is an example of a tuple that checks for a string and a number: local tuple = q.tuple(q.string, q.number) tuple(&quot;1&quot;, 1) -- true tuple(1, &quot;1&quot;) -- false   "},{"title":"VariantContext​","type":1,"pageTitle":"q","url":"api/q#VariantContext","content":"&lt;/&gt; interface VariantContext { TypeName: string } A context object that is passed to the handler function of a variant. It contains the typename of the object being checked.  "},{"title":"Variant​","type":1,"pageTitle":"q","url":"api/q#Variant","content":"&lt;/&gt; type Variant = QType A type that can represent many types. This can be compared with unions in C. Variants are created using q.variant. Here is an example of a variant that checks for a string or a number: local variant = q.variant(q.string, q.number) variant(&quot;1&quot;) -- true variant(1) -- true variant(true) -- false tip I would recommend using q.nullable over q.variant for optional arguments.  "},{"title":"InterfaceContext​","type":1,"pageTitle":"q","url":"api/q#InterfaceContext","content":"&lt;/&gt; interface InterfaceContext { TypeName: string InvalidKey: boolean Key: string } A context object that is passed to the handler function of an interface. It contains the typename of the object being checked, whether or not the key is invalid (see StrictInterface), and the key of the object in the table.  "},{"title":"Interface​","type":1,"pageTitle":"q","url":"api/q#Interface","content":"&lt;/&gt; type Interface = QType A type that serves as a guide for a table. It can be used to check if a table has the correct typed values. tip You can use this for sanitizing tables sent to RemoteEvents and RemoteFunctions to ensure that the data is valid. This guarantees that the thread doesn't error on behalf of the user (such as an exploiter) and possibly cause the server to hang or crash. Interfaces are created using q.interface. Here is an example of an interface that checks for a string and a number: local interface = q.interface({ Name = q.string, Age = q.number, }) interface({ Name = &quot;Nicholas&quot;, Age = 15 }) -- true interface({ Name = &quot;Nicholas&quot;, Age = &quot;15&quot; }) -- false   "},{"title":"StrictInterface​","type":1,"pageTitle":"q","url":"api/q#StrictInterface","content":"&lt;/&gt; type StrictInterface = QType A type that serves as a guide for a table. It can be used to check if a table has the correct typed values. Unlike Interface, StrictInterface will not allow extra keys in the table. Strict interfaces are created using q.strictInterface. Here is an example of a strict interface that checks for a string and a number: local interface = q.strictInterface({ Name = q.string, Age = q.number, }) interface({ Name = &quot;Nicholas&quot;, Age = 15 }) -- true interface({ Name = &quot;Nicholas&quot;, Age = &quot;15&quot; }) -- false interface({ Name = &quot;Nicholas&quot;, Age = 15, Extra = true }) -- false   "},{"title":"Nullable​","type":1,"pageTitle":"q","url":"api/q#Nullable","content":"&lt;/&gt; type Nullable = QType A type that serves as null or another type. Another way of saying q.variant(null, type). This is useful for optional arguments. Nullables are created using q.nullable. Here is an example of a nullable that checks for a string or null: local nullable = q.nullable(q.string) nullable(&quot;1&quot;) -- true nullable(nil) -- true nullable(1) -- false Another way of doing this is by using q.variant: local variant = q.variant(q.string, q.null) variant(&quot;1&quot;) -- true variant(nil) -- true variant(1) -- false  "},{"title":"Properties​","type":1,"pageTitle":"q","url":"api/q#properties","content":" "},{"title":"qtype​","type":1,"pageTitle":"q","url":"api/q#qtype","content":"built-in &lt;/&gt; q.qtype: QType A qtype that checks if an object is a qtype: local q = require(path.to.q) q.qtype(q.string) -- true q.qtype(&quot;string&quot;) -- false   "},{"title":"null​","type":1,"pageTitle":"q","url":"api/q#null","content":"built-in &lt;/&gt; q.null: QType A type that represents nil: q.null() -- true q.null(nil) -- true q.null(1) -- false   "},{"title":"bool​","type":1,"pageTitle":"q","url":"api/q#bool","content":"built-in &lt;/&gt; q.bool: QType A type that represents a boolean (true or false): q.bool(true) -- true q.bool(false) -- true q.bool(1) -- false   "},{"title":"number​","type":1,"pageTitle":"q","url":"api/q#number","content":"built-in &lt;/&gt; q.number: QType A type that represents a number: q.number(1) -- true q.number(1.1) -- true q.number(&quot;1&quot;) -- false   "},{"title":"string​","type":1,"pageTitle":"q","url":"api/q#string","content":"built-in &lt;/&gt; q.string: QType A type that represents a string: q.string(&quot;1&quot;) -- true q.string(1) -- false   "},{"title":"func​","type":1,"pageTitle":"q","url":"api/q#func","content":"built-in &lt;/&gt; q.func: QType A type that represents a function: q.func(function() end) -- true q.func(1) -- false   "},{"title":"userdata​","type":1,"pageTitle":"q","url":"api/q#userdata","content":"built-in &lt;/&gt; q.userdata: QType A type that represents a userdata: q.userdata(newproxy()) -- true q.userdata(1) -- false   "},{"title":"thread​","type":1,"pageTitle":"q","url":"api/q#thread","content":"built-in &lt;/&gt; q.thread: QType A type that represents a thread (coroutine): q.thread(coroutine.create(function() end)) -- true q.thread(1) -- false   "},{"title":"table​","type":1,"pageTitle":"q","url":"api/q#table","content":"built-in &lt;/&gt; q.table: QType A type that represents a table: q.table({}) -- true q.table(1) -- false   "},{"title":"any​","type":1,"pageTitle":"q","url":"api/q#any","content":"&lt;/&gt; q.any: QType A type that serves as any type. This is useful for when you don't know the type of a value. warning The point of this library is to reduce type errors. Using this type when not needed can cause unexpected behavior. It's recommended to use q.variant when applicable. If you have no clue what you're doing or if you plan to use only the any type, then you're better off not using this library at all, and sticking without type checking. The any type is created using q.any. Here is an example of doing that: local any = q.any() any(&quot;1&quot;) -- true any(1) -- true any(nil) -- true  "},{"title":"Functions​","type":1,"pageTitle":"q","url":"api/q#functions","content":" "},{"title":"custom​","type":1,"pageTitle":"q","url":"api/q#custom","content":"&lt;/&gt; q.custom( name: string,-- The name of the qtype handler: function-- The handler function for the qtype ) → qtype-- The blank qtype object Creates a blank qtype object. This can be used to create your own custom types to be used with the library.  "},{"title":"typeName​","type":1,"pageTitle":"q","url":"api/q#typeName","content":"&lt;/&gt; q.typeName( obj: any-- The name of the qtype ) → string-- Returns the typename of the given object Returns the typename of the given object.  "},{"title":"assert​","type":1,"pageTitle":"q","url":"api/q#assert","content":"&lt;/&gt; q.assert( res: boolean,-- The result of the typecheck err: string-- The error message ) → void Errors with 'err' if the typecheck fails.  "},{"title":"wrap​","type":1,"pageTitle":"q","url":"api/q#wrap","content":"&lt;/&gt; q.wrap( f: (...: any) → (...: any),-- The callback function ...: qtype-- The qtypes to check arguments against ) → (...: any) → (...: any)-- The wrapped function Creates a function that will create a tuple then assert the tuple before calling the callback.  "},{"title":"pwrap​","type":1,"pageTitle":"q","url":"api/q#pwrap","content":"&lt;/&gt; q.pwrap( f: (...: any) → (...: any),-- The callback function processors: {ProcessorHandler&lt;T&gt;},-- A list of processor functions qtypes: {QType}-- The types to check against ) → (...: any) → (...: any)-- The wrapped function Creates a function that will create a tuple then assert the tuple before calling the callback. This function will also process the arguments before calling the callback. This is really ugly, so if anyone has a better way to do this, please let me know.  "},{"title":"tuple​","type":1,"pageTitle":"q","url":"api/q#tuple","content":"&lt;/&gt; q.tuple( ...: QType-- The types to check against ) → Tuple&lt;T&gt;-- The tuple type Creates a tuple type. Accepts any number of qtypes as arguments. The handler will return a TupleContext object as the context argument if the check fails.  "},{"title":"variant​","type":1,"pageTitle":"q","url":"api/q#variant","content":"&lt;/&gt; q.variant( ...: QType-- The types to check against ) → Variant&lt;T&gt;-- The variant type Creates a variant type, which can stand for any given type in the arguments. The handler will return a VariantContext object as the context argument if the check succeeds.  "},{"title":"interface​","type":1,"pageTitle":"q","url":"api/q#interface","content":"&lt;/&gt; q.interface( base: table-- The base table ) → Interface&lt;T&gt;-- The interface type Creates an interface type. Accepts a table of keys to qtype values. The handler will return an InterfaceContext object as the context argument if the check fails.  "},{"title":"strictInterface​","type":1,"pageTitle":"q","url":"api/q#strictInterface","content":"&lt;/&gt; q.strictInterface( base: table-- The base table ) → StrictInterface&lt;T&gt;-- The interface type Creates a strict interface type. Since it's strict, new keys cannot exist in the table when checking. Accepts a table of keys to qtype values. The handler will return an InterfaceContext object as the context argument if the check fails.  "},{"title":"nullable​","type":1,"pageTitle":"q","url":"api/q#nullable","content":"&lt;/&gt; q.nullable( t: QType-- The type to make nullable ) → Nullable&lt;T&gt;-- The nullable type Creates a nullable type. Accepts a qtype as an argument. "}]