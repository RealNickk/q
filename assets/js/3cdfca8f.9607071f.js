"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[830],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(n),f=r,m=p["".concat(l,".").concat(f)]||p[f]||h[f]||s;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<s;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},77573:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:4},i="The Basics of q",o={unversionedId:"basics",id:"basics",title:"The Basics of q",description:"If you have not read the Is q Something I want to Use",source:"@site/docs/basics.md",sourceDirName:".",slug:"/basics",permalink:"/q/docs/basics",draft:!1,editUrl:"https://github.com/RealNickk/q/edit/master/docs/basics.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Installation",permalink:"/q/docs/Installation"}},l={},u=[{value:"Syntax",id:"syntax",level:2},{value:"Everyday Use",id:"everyday-use",level:2},{value:"Nullables",id:"nullables",level:2},{value:"Variants",id:"variants",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Interfaces",id:"interfaces",level:2},{value:"Strict Interfaces",id:"strict-interfaces",level:2},{value:"User-Defined Types",id:"user-defined-types",level:2},{value:"Processors",id:"processors",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:u};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"the-basics-of-q"},"The Basics of q"),(0,r.kt)("p",null,"If you have not read the ",(0,r.kt)("a",{parentName:"p",href:"IsQSomethingIWantToUse"},"Is q Something I want to Use"),"\npage, I highly recommend you do so before continuing. It will give you a better\nunderstanding of what q is and what it can do. I'd hate to waste your time if\nyou don't want to use q."),(0,r.kt)("p",null,"In this article, I will be going over the basics of q. I will be going over the\nsyntax and how to use it. I will also be going over some of the features of q\nthat you may not know about, such as custom types and interfaces."),(0,r.kt)("h2",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"q is a typechecking library, but it's built to run without having to rewrite the\ncompiler. It's built to run on top of vanilla Lua, which means that it's\ncompatible with a couple of versions of Lua, namely 5.1, 5.2, 5.3, and LuaJIT."),(0,r.kt)("p",null,"q is built to be as simple as possible, so it's syntax is very simple. It's\nsyntax isn't similar to Luau's syntax, but it's easy to learn and easy to use.\nHere's an example of q's syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local q = require(game:GetService("ReplicatedStorage").q)\nprint(q.string("Hello, world!")) --\x3e true\n')),(0,r.kt)("p",null,"The first line is the same as any other require statement. The second line is\nwhere the magic happens. The property you choose is the type you want to check\nagainst. If the value is the type you specified, it will return true. If it's\nnot, it will return false with argument 2 as the error message, and a possible\nthird argument as the context which can be read about in the API reference."),(0,r.kt)("h2",{id:"everyday-use"},"Everyday Use"),(0,r.kt)("p",null,"q is built to be used in everyday Lua code. Whether it's a Roblox game or a\nseperate base, q is built to be used in any situation. Here's an example of\nq being used in a Roblox game:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'if q.string("Hello, world!") then\n    print("This is a string!")\nelse\n    warn("This is not a string!")\nend\n')),(0,r.kt)("p",null,"In this example, we're checking if the value is a string. If it is, we print\n\"This is a string!\". If it's not, we follow the else statement and warn the\nplayer that it's not a string. This is useful for checking if a value is the\ntype you want it to be. It's also useful for checking if a value is a certain\ntype before doing something with it."),(0,r.kt)("p",null,"q supports all of the vanilla Lua types, as well as some custom types. Some of\nthe custom types will be explained next."),(0,r.kt)("h2",{id:"nullables"},"Nullables"),(0,r.kt)("p",null,"q supports nullables. This means that you can check if a value is a certain\ntype, or nil. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local nullOrString = q.nullable(q.string)\nprint(nullOrString("Hello, world!")) --\x3e true\nprint(nullOrString(nil)) --\x3e true\nprint(nullOrString(1)) --\x3e false\n')),(0,r.kt)("p",null,"In this example, we're checking if the value is a string or nil. If it is, it\nwill return true. If it's not, it will return false. I would recommend using\nthis over variants, as it's easier to use and easier to read."),(0,r.kt)("h2",{id:"variants"},"Variants"),(0,r.kt)("p",null,"Variants are a type that can be multiple types. They are useful for functions\nthat can take multiple types at once. Here's an example of a variant:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local variant = q.variant(q.string, q.number)\nprint(variant("Hello, world!")) --\x3e true\nprint(variant(2007)) --\x3e true\nprint(variant(true)) --\x3e false\n')),(0,r.kt)("p",null,"In this example, we're creating a new variant type. We're telling q that the\nvariant can be a string or a number. We then check if the value is a string,\nwhich it is, so it returns true. After that, we checkif the value is a number,\nwhich it is, so it returns true. Lastly, we check if the value is a boolean,\nwhich it isn't, so it returns false."),(0,r.kt)("h2",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Tuples are a list of values. They are useful for functions that take multiple\narguments. Here's an example of a tuple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local tuple = q.tuple(q.string, q.number)\nprint(tuple("Hello, world!", 2007)) --\x3e true\nprint(tuple("Hello, world!", true)) --\x3e false\n')),(0,r.kt)("p",null,"In this example, we're creating a new tuple type. We're telling q that the\ntuple is a list: ","[string, number]",". We then check if the values are a string\nand a number, which they are, so it returns true. Afterwards, we check if the\nvalues are a string and a boolean, which they aren't, so it returns false."),(0,r.kt)("h2",{id:"interfaces"},"Interfaces"),(0,r.kt)("p",null,"Interfaces are a way to check if a table has certain properties. They can be\nused to check if a table has a certain method, or if it has a certain property.\nHere's an example of an interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local person = q.interface({\n    Name = q.string,\n    Age = q.number\n})\nprint(person({ Name = "Nicholas", Age = 15 })) --\x3e true\nprint(person({ Name = "Nicholas", Age = 15, Extra = true })) --\x3e true\nprint(person({ Name = "Nicholas", Age = false })) --\x3e false\n')),(0,r.kt)("p",null,"In this example, we're creating a new interface type. We're telling q that the\ninterface is a table with the properties Name and Age. We then check if the\nfirst table matches the interface, which it does, so it returns true. After\nthat, we check if the second table matches the interface, which it does, so it\nreturns true. Lastly, we check if the third table matches the interface, which\nit doesn't, so it returns false."),(0,r.kt)("h2",{id:"strict-interfaces"},"Strict Interfaces"),(0,r.kt)("p",null,"Strict interfaces are pretty much 100% the same as interfaces, but they're\nstrict. They're strict in the sense that they don't allow extra properties.\nHere's an example of a strict interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local person = q.strictInterface({\n    Name = q.string,\n    Age = q.number\n})\nprint(person({ Name = "Nicholas", Age = 15 })) --\x3e true\nprint(person({ Name = "Nicholas", Age = 15, Extra = true })) --\x3e false\nprint(person({ Name = "Nicholas", Age = false })) --\x3e false\n')),(0,r.kt)("p",null,"In this example, you can see that the table with the extra property returns\nfalse. This is because strict interfaces don't allow extra properties. The\nfirst table returns true because it doesn't have any extra properties."),(0,r.kt)("h2",{id:"user-defined-types"},"User-Defined Types"),(0,r.kt)("p",null,"The nice thing about having q is that it's flexible. You can use it in any\nsituation, and you can create your own types to make up for other types that\nq doesn't have. Here's an example of using a custom type, where variants are\nnot the best option:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'q.numberString = q.custom("numberString", function(self, obj)\n    return q.string(obj) and (tonumber(obj) ~= nil) or q.number(obj)\nend)\n\nlocal doSomething = q.wrap(function(value)\n    value = tonumber(value)\n    print(type(value))\nend, q.numberString)\n\ndoSomething(1234)   --\x3e number\ndoSomething("5678") --\x3e number\ndoSomething("Hello, world!") --\x3e invalid argument #1 (expected numberString, got string)\n')),(0,r.kt)("p",null,"In this example, we're creating a new type called \"numberString\". A numberString\nis a type that can be either a number or a string that can be converted to a\nnumber. We then create a function that takes a numberString as an argument. We\nthen call the function with a number, a string that can be converted to a\nnumber, and a string that can't be converted to a number. The first two calls\nwork, but the third one doesn't. This is because the third call is a string that\ncan't be converted to a number, and q.numberString only allows strings that can\nbe converted to numbers."),(0,r.kt)("h2",{id:"processors"},"Processors"),(0,r.kt)("p",null,"Do you see a problem in the last snippet? There is an issue with that code. The\nissue is that you have to still input boilerplate code to convert the string to\na number. This is where processors come in. A processor is a function that runs\nafter the function is called. It's useful for converting values to the type you\nwant them to be. The problem with processors is that it makes it a lot harder to\nunderstand the code, and you're probably better off not using processors unless\nyou really need them. Here's an example of using a processor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'q.numberString = q.custom("numberString", function(self, obj)\n    return q.string(obj) and (tonumber(obj) ~= nil) or q.number(obj)\nend)\n\nq.processNumberString = function(obj)\n    return tonumber(obj)\nend\n\nlocal function _doSomething(value)\n    print(type(value))\nend\n\nlocal doSomething = q.pwrap( -- note that it\'s pwrap (wrap and process), not wrap\n    _doSomething,\n    { q.processNumberString },\n    { q.numberString }\n)\n\ndoSomething(1234)   --\x3e number\ndoSomething("5678") --\x3e number\ndoSomething("Hello, world!") --\x3e invalid argument #1 (expected numberString, got string)\n')),(0,r.kt)("p",null,"Processors call regardless of whether or not the value is the type you want it\nto be. It acts as the type but also converts the value to what you want.\nHowever, this is really ugly. You have to create a new function, and you have to\ncreate a new table for both the processors and arguments. I was unable to find a\nway to make this better, so if you have any suggestions, please let me know and\nI'll see what I can do."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"I went over the basics of q, including types, variants, tuples, interfaces,\nstrict interfaces, user-defined types, and processors. I hope you learned\nsomething new. If you have any questions, feel free to ask me through the\ncontact methods listed on my GitHub. If you're interested in contributing to\nq, feel free to make a pull request on GitHub. If you like my work, feel free\nto star the repository on GitHub. If you are interested in any other projects\nI've made, feel free to check out my GitHub profile."),(0,r.kt)("p",null,"Thanks for reading!"))}h.isMDXComponent=!0}}]);