"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[254],{52171:e=>{e.exports=JSON.parse('{"functions":[{"name":"custom","desc":"Creates a blank `qtype` object. This can be used to create your\\nown custom types to be used with the library.","params":[{"name":"name","desc":"The name of the qtype","lua_type":"string"},{"name":"handler","desc":"The handler function for the qtype","lua_type":"function"}],"returns":[{"desc":"The blank qtype object","lua_type":"qtype"}],"function_type":"static","source":{"line":81,"path":"src/q.lua"}},{"name":"typeName","desc":"Returns the typename of the given object.","params":[{"name":"obj","desc":"The name of the qtype","lua_type":"any"}],"returns":[{"desc":"Returns the typename of the given object","lua_type":"string"}],"function_type":"static","source":{"line":100,"path":"src/q.lua"}},{"name":"assert","desc":"Errors with \'err\' if the typecheck fails.","params":[{"name":"res","desc":"The result of the typecheck","lua_type":"boolean"},{"name":"err","desc":"The error message","lua_type":"string"}],"returns":[{"desc":"","lua_type":"void"}],"function_type":"static","source":{"line":114,"path":"src/q.lua"}},{"name":"wrap","desc":"Creates a function that will create a tuple then\\nassert the tuple before calling the callback.","params":[{"name":"f","desc":"The callback function","lua_type":"(...: any) -> (...: any)"},{"name":"...","desc":"The qtypes to check arguments against","lua_type":"qtype"}],"returns":[{"desc":"The wrapped function","lua_type":"(...: any) -> (...: any)"}],"function_type":"static","source":{"line":126,"path":"src/q.lua"}},{"name":"pwrap","desc":"Creates a function that will create a tuple then\\nassert the tuple before calling the callback. This\\nfunction will also process the arguments before\\ncalling the callback.\\n\\nThis is really ugly, so if anyone has a better way to do this,\\nplease let me know.","params":[{"name":"f","desc":"The callback function","lua_type":"(...: any) -> (...: any)"},{"name":"processors","desc":"A list of processor functions","lua_type":"{ProcessorHandler<T>}"},{"name":"qtypes","desc":"The types to check against","lua_type":"{QType}"}],"returns":[{"desc":"The wrapped function","lua_type":"(...: any) -> (...: any)"}],"function_type":"static","source":{"line":181,"path":"src/q.lua"}},{"name":"tuple","desc":"Creates a tuple type. Accepts any number of qtypes as arguments.\\nThe handler will return a [TupleContext] object as the `context`\\nargument if the check fails.","params":[{"name":"...","desc":"The types to check against","lua_type":"QType"}],"returns":[{"desc":"The tuple type","lua_type":"Tuple<T>"}],"function_type":"static","source":{"line":445,"path":"src/q.lua"}},{"name":"variant","desc":"Creates a variant type, which can stand for any given type in the\\narguments. The handler will return a [VariantContext] object as\\nthe `context` argument if the check succeeds.","params":[{"name":"...","desc":"The types to check against","lua_type":"QType"}],"returns":[{"desc":"The variant type","lua_type":"Variant<T>"}],"function_type":"static","source":{"line":502,"path":"src/q.lua"}},{"name":"interface","desc":"Creates an interface type. Accepts a table of keys to qtype values.\\nThe handler will return an [InterfaceContext] object as the `context`\\nargument if the check fails.","params":[{"name":"base","desc":"The base table","lua_type":"table"}],"returns":[{"desc":"The interface type","lua_type":"Interface<T>"}],"function_type":"static","source":{"line":572,"path":"src/q.lua"}},{"name":"strictInterface","desc":"Creates a strict interface type. Since it\'s strict, new keys cannot exist\\nin the table when checking. Accepts a table of keys to qtype values. The\\nhandler will return an [InterfaceContext] object as the `context` argument\\nif the check fails.","params":[{"name":"base","desc":"The base table","lua_type":"table"}],"returns":[{"desc":"The interface type","lua_type":"StrictInterface<T>"}],"function_type":"static","source":{"line":630,"path":"src/q.lua"}},{"name":"nullable","desc":"Creates a nullable type. Accepts a qtype as an argument.","params":[{"name":"t","desc":"The type to make nullable","lua_type":"QType"}],"returns":[{"desc":"The nullable type","lua_type":"Nullable<T>"}],"function_type":"static","source":{"line":674,"path":"src/q.lua"}}],"properties":[{"name":"qtype","desc":"A qtype that checks if an object is a qtype:\\n```lua\\nlocal q = require(path.to.q)\\nq.qtype(q.string) -- true\\nq.qtype(\\"string\\") -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":262,"path":"src/q.lua"}},{"name":"null","desc":"A type that represents `nil`:\\n```lua\\nq.null()    -- true\\nq.null(nil) -- true\\nq.null(1)   -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":293,"path":"src/q.lua"}},{"name":"bool","desc":"A type that represents a `boolean` (true or false):\\n```lua\\nq.bool(true)  -- true\\nq.bool(false) -- true\\nq.bool(1)     -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":308,"path":"src/q.lua"}},{"name":"number","desc":"A type that represents a `number`:\\n```lua\\nq.number(1)   -- true\\nq.number(1.1) -- true\\nq.number(\\"1\\") -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":323,"path":"src/q.lua"}},{"name":"string","desc":"A type that represents a `string`:\\n```lua\\nq.string(\\"1\\") -- true\\nq.string(1)   -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":336,"path":"src/q.lua"}},{"name":"func","desc":"A type that represents a `function`:\\n```lua\\nq.func(function() end) -- true\\nq.func(1)              -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":349,"path":"src/q.lua"}},{"name":"userdata","desc":"A type that represents a `userdata`:\\n```lua\\nq.userdata(newproxy()) -- true\\nq.userdata(1)          -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":364,"path":"src/q.lua"}},{"name":"thread","desc":"A type that represents a `thread` (coroutine):\\n```lua\\nq.thread(coroutine.create(function() end)) -- true\\nq.thread(1)                                -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":377,"path":"src/q.lua"}},{"name":"table","desc":"A type that represents a `table`:\\n```lua\\nq.table({}) -- true\\nq.table(1)  -- false\\n```","lua_type":"QType","tags":["built-in"],"source":{"line":390,"path":"src/q.lua"}},{"name":"any","desc":"A type that serves as any type. This is useful for when you don\'t\\nknow the type of a value.\\n\\n:::warning\\nThe point of this library is to reduce type errors. Using\\nthis type when not needed can cause unexpected behavior.\\nIt\'s recommended to use [q.variant] when applicable.\\n\\nIf you have no clue what you\'re doing or if you plan to use\\nonly the `any` type, then you\'re better off not using this\\nlibrary at all, and sticking without type checking.\\n:::\\n\\nThe `any` type is created using [q.any]. Here is an example\\nof doing that:\\n```lua\\nlocal any = q.any()\\nany(\\"1\\")  -- true\\nany(1)    -- true\\nany(nil)  -- true\\n```","lua_type":"QType","source":{"line":705,"path":"src/q.lua"}}],"types":[{"name":"Handler","desc":"A handler function for a [QType]. This function takes in any\\nnumber of parameters with any type. The first return argument\\nis a boolean indicating whether the typecheck passed or not.\\nThe second return argument is the error message if the\\ntypecheck failed. The third return argument is returned for\\nextra context on the object.\\n\\n:::note\\nThe `context` argument is only passed when needed. In\\ndocumentation, it will explicitly state if and when it is\\npassed, and there will be an interface defined for it.\\n:::\\n\\nHere is a code snippet of a handler function:\\n```lua\\nlocal function isInstance(obj)\\n    local typeName = typeof(obj)\\n    if typeName ~= \\"Instance\\" then\\n        return false,\\n            string.format(\\"expected an Instance, got %s\\", typeName),\\n            { ObjectType = typeName }\\n    end\\n    return true\\nend\\n```","lua_type":"(...: any) -> (success: boolean, err: string?, context: table?)","source":{"line":72,"path":"src/q.lua"}},{"name":"ProcessorHandler","desc":"A function that processes a value. This is used in [q.pwrap].\\n\\n```lua\\nq.numberString = q.custom(\\"numberString\\", function(self, obj)\\n    return q.string(obj) and (tonumber(obj) ~= nil) or q.number(obj)\\nend)\\n\\nq.processNumberString = function(obj)\\n    return tonumber(obj)\\nend\\n\\nlocal function _doSomething(value)\\n    print(type(value))\\nend\\n\\nlocal doSomething = q.pwrap(\\n    _doSomething,\\n    { q.processNumberString },\\n    { q.numberString }\\n)\\n\\ndoSomething(1234)   --\x3e number\\ndoSomething(\\"5678\\") --\x3e number\\ndoSomething(\\"Hello, world!\\") --\x3e invalid argument #1 (expected numberString, got string)\\n```\\n\\nThis is really ugly, so if anyone has a better way to do this,\\nplease let me know.","lua_type":"(obj: T) -> any","source":{"line":166,"path":"src/q.lua"}},{"name":"QType","desc":"A custom type defined by the user. These can be called like\\na function with parameters to typecheck them. Refer to [Handler]\\nfor more information on how to call these user-defined types.\\n\\nYou can get the typename of a QType by using [q.typeName].\\n:::warning\\nQTypes are not meant to be used with `type` or `typeof`. You must use\\n`q.typeName` to get the name of a QType. `q.typeName` will fallback\\nto the `typeof` function for ease of use.\\n:::\\n\\nQTypes can be accessed and written to like a table for use\\nin the handler function.\\n:::caution\\nIn some versions of Lua, QTypes are userdatas. In newer versions of Lua,\\nQTypes are tables. This is due to the fact that `newproxy` was removed\\nin newer versions of Lua. This library will automatically detect if your\\nversion of Lua can create userdatas from code. However, this means that\\nyou should __NEVER__ use `q.userdata` or `q.table` to check if an object\\nis a QType. Instead, use [q.qtype] to check if an object is a QType.\\n\\nYou can still access and write to the QType like a table, but you must\\nuse `q.isQType` to check if an object is a QType.\\n:::\\n\\nQTypes are created using [q.custom]. Here is an example of adding\\nsupport for an `Instance` type:\\n```lua\\nlocal q = require(path.to.q)\\nq.instance = q.custom(\\"Instance\\", function(obj)\\n    local typeName = typeof(obj)\\n    if typeName ~= \\"Instance\\" then\\n        return false,\\n            string.format(\\"expected an Instance, got %s\\", typeName),\\n            { ObjectType = typeName }\\n    end\\n    return true\\nend)\\nq.instance(game)    -- true\\nq.instance(\\"hello\\") -- false\\n```","lua_type":"userdata | table","source":{"line":240,"path":"src/q.lua"}},{"name":"TupleContext","desc":"A context object that is passed to the handler function of a tuple.\\nIt contains the typename of the object being checked and the index\\nof the object in the tuple.","fields":[{"name":"TypeName","lua_type":"string","desc":""},{"name":"Index","lua_type":"number","desc":""}],"source":{"line":403,"path":"src/q.lua"}},{"name":"Tuple","desc":"A type that represents arguments or parameters to\\na function. Tuples can also be used to typeheck\\nnumbered tables (lists).\\n\\nTuples are created using [q.tuple]. Here is an example\\nof a tuple that checks for a `string` and a `number`:\\n```lua\\nlocal tuple = q.tuple(q.string, q.number)\\ntuple(\\"1\\", 1) -- true\\ntuple(1, \\"1\\") -- false\\n```","lua_type":"QType","source":{"line":419,"path":"src/q.lua"}},{"name":"VariantContext","desc":"A context object that is passed to the handler function of a variant.\\nIt contains the typename of the object being checked.","fields":[{"name":"TypeName","lua_type":"string","desc":""}],"source":{"line":459,"path":"src/q.lua"}},{"name":"Variant","desc":"A type that can represent many types. This can be compared\\nwith unions in C.\\n\\nVariants are created using [q.variant]. Here is an example\\nof a variant that checks for a `string` or a `number`:\\n```lua\\nlocal variant = q.variant(q.string, q.number)\\nvariant(\\"1\\")  -- true\\nvariant(1)    -- true\\nvariant(true) -- false\\n```\\n\\n:::tip\\nI would recommend using [q.nullable] over [q.variant] for optional arguments.\\n:::","lua_type":"QType","source":{"line":479,"path":"src/q.lua"}},{"name":"InterfaceContext","desc":"A context object that is passed to the handler function of an\\ninterface. It contains the typename of the object being checked,\\nwhether or not the key is invalid (see [StrictInterface]), and\\nthe key of the object in the table.","fields":[{"name":"TypeName","lua_type":"string","desc":""},{"name":"InvalidKey","lua_type":"boolean","desc":""},{"name":"Key","lua_type":"string","desc":""}],"source":{"line":520,"path":"src/q.lua"}},{"name":"Interface","desc":"A type that serves as a guide for a table. It can be used to\\ncheck if a table has the correct typed values.\\n\\n:::tip\\nYou can use this for sanitizing tables sent to `RemoteEvents`\\nand `RemoteFunctions` to ensure that the data is valid. This\\nguarantees that the thread doesn\'t error on behalf of the user\\n(such as an exploiter) and possibly cause the server to hang\\nor crash.\\n:::\\n\\nInterfaces are created using [q.interface]. Here is an example\\nof an interface that checks for a `string` and a `number`:\\n```lua\\nlocal interface = q.interface({\\n    Name = q.string,\\n    Age  = q.number,\\n})\\ninterface({ Name = \\"Nicholas\\", Age = 15 })   -- true\\ninterface({ Name = \\"Nicholas\\", Age = \\"15\\" }) -- false\\n```","lua_type":"QType","source":{"line":546,"path":"src/q.lua"}},{"name":"StrictInterface","desc":"A type that serves as a guide for a table. It can be used to\\ncheck if a table has the correct typed values. Unlike `Interface`,\\n`StrictInterface` will not allow extra keys in the table.\\n\\nStrict interfaces are created using [q.strictInterface]. Here is an example\\nof a strict interface that checks for a `string` and a `number`:\\n```lua\\nlocal interface = q.strictInterface({\\n    Name = q.string,\\n    Age  = q.number,\\n})\\ninterface({ Name = \\"Nicholas\\", Age = 15 })   -- true\\ninterface({ Name = \\"Nicholas\\", Age = \\"15\\" }) -- false\\ninterface({ Name = \\"Nicholas\\", Age = 15, Extra = true }) -- false\\n```","lua_type":"QType","source":{"line":597,"path":"src/q.lua"}},{"name":"Nullable","desc":"A type that serves as `null` or another type. Another way of saying\\n`q.variant(null, type)`. This is useful for optional arguments.\\n\\nNullables are created using [q.nullable]. Here is an example\\nof a nullable that checks for a `string` or `null`:\\n```lua\\nlocal nullable = q.nullable(q.string)\\nnullable(\\"1\\")  -- true\\nnullable(nil)  -- true\\nnullable(1)    -- false\\n```\\n\\nAnother way of doing this is by using [q.variant]:\\n```lua\\nlocal variant = q.variant(q.string, q.null)\\nvariant(\\"1\\")  -- true\\nvariant(nil)  -- true\\nvariant(1)    -- false\\n```","lua_type":"QType","source":{"line":659,"path":"src/q.lua"}}],"name":"q","desc":"A class that allows you to manage runtime types.\\nThis class provides a way to check if a value is of\\na certain type, a way to handle typechecking errors,\\nand a way to define your own custom types for\\ngeneral use.","source":{"line":41,"path":"src/q.lua"}}')}}]);